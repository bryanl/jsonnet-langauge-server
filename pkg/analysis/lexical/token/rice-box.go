package token

import (
	"github.com/GeertJohan/go.rice/embedded"
	"time"
)

func init() {

	// define files
	file2 := &embedded.EmbeddedFile{
		Filename:    "std.jsonnet",
		FileModTime: time.Unix(1535557040, 0),
		Content:     string("/*\nCopyright 2015 Google Inc. All rights reserved.\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n*/\n\n/* This is the Jsonnet standard library, at least the parts of it that are written in Jsonnet.\n *\n * There are some native methods as well, which are defined in the interpreter and added to this\n * file.  It is never necessary to import std.jsonnet, it is embedded into the interpreter at\n * compile-time and automatically imported into all other Jsonnet programs.\n */\n{\n\n  local std = self,\n  local id = function(x) x,\n\n  isString(v):: std.type(v) == 'string',\n  isNumber(v):: std.type(v) == 'number',\n  isBoolean(v):: std.type(v) == 'boolean',\n  isObject(v):: std.type(v) == 'object',\n  isArray(v):: std.type(v) == 'array',\n  isFunction(v):: std.type(v) == 'function',\n\n  toString(a)::\n    if std.type(a) == 'string' then a else '' + a,\n\n  substr(str, from, len)::\n    if std.type(str) != 'string' then\n      error 'substr first parameter should be a string, got ' + std.type(str)\n    else if std.type(from) != 'number' then\n      error 'substr second parameter should be a number, got ' + std.type(from)\n    else if std.type(len) != 'number' then\n      error 'substr third parameter should be a number, got ' + std.type(len)\n    else if len < 0 then\n      error 'substr third parameter should be greater than zero, got ' + len\n    else\n      std.join('', std.makeArray(len, function(i) str[i + from])),\n\n  startsWith(a, b)::\n    if std.length(a) < std.length(b) then\n      false\n    else\n      std.substr(a, 0, std.length(b)) == b,\n\n  endsWith(a, b)::\n    if std.length(a) < std.length(b) then\n      false\n    else\n      std.substr(a, std.length(a) - std.length(b), std.length(b)) == b,\n\n  stringChars(str)::\n    std.makeArray(std.length(str), function(i) str[i]),\n\n  local parse_nat(str, base) =\n    assert base > 0 && base <= 16 : 'integer base %d invalid' % base;\n    // These codepoints are in ascending order:\n    local zero_code = std.codepoint('0');\n    local upper_a_code = std.codepoint('A');\n    local lower_a_code = std.codepoint('a');\n    local addDigit(aggregate, char) =\n      local code = std.codepoint(char);\n      local digit = if code > lower_a_code then\n        code - lower_a_code + 10\n      else if code > upper_a_code then\n        code - upper_a_code + 10\n      else\n        code - zero_code;\n      assert digit >= 0 && digit < base : '%s is not a base %d integer' % [str, base];\n      base * aggregate + digit;\n    std.foldl(addDigit, std.stringChars(str), 0),\n\n  parseInt(str)::\n    if str[0] == '-' then\n      -parse_nat(str[1:], 10)\n    else\n      parse_nat(str, 10),\n\n  parseOctal(str)::\n    assert std.isString(str): 'Expected string, got ' + std.type(str);\n    assert std.length(str) > 0: 'Not an octal number: \"\"';\n    parse_nat(str, 8),\n\n  parseHex(str)::\n    assert std.isString(str): 'Expected string, got ' + std.type(str);\n    assert std.length(str) > 0: 'Not hexadecimal: \"\"';\n    parse_nat(str, 16),\n\n  split(str, c)::\n    if std.type(str) != 'string' then\n      error 'std.split first parameter should be a string, got ' + std.type(str)\n    else if std.type(c) != 'string' then\n      error 'std.split second parameter should be a string, got ' + std.type(c)\n    else if std.length(c) != 1 then\n      error 'std.split second parameter should have length 1, got ' + std.length(c)\n    else\n      std.splitLimit(str, c, -1),\n\n  splitLimit(str, c, maxsplits)::\n    if std.type(str) != 'string' then\n      error 'std.splitLimit first parameter should be a string, got ' + std.type(str)\n    else if std.type(c) != 'string' then\n      error 'std.splitLimit second parameter should be a string, got ' + std.type(c)\n    else if std.length(c) != 1 then\n      error 'std.splitLimit second parameter should have length 1, got ' + std.length(c)\n    else if std.type(maxsplits) != 'number' then\n      error 'std.splitLimit third parameter should be a number, got ' + std.type(maxsplits)\n    else\n      local aux(str, delim, i, arr, v) =\n        local c = str[i];\n        local i2 = i + 1;\n        if i >= std.length(str) then\n          arr + [v]\n        else if c == delim && (maxsplits == -1 || std.length(arr) < maxsplits) then\n          aux(str, delim, i2, arr + [v], '') tailstrict\n        else\n          aux(str, delim, i2, arr, v + c) tailstrict;\n      aux(str, c, 0, [], ''),\n\n  strReplace(str, from, to)::\n    assert std.type(str) == 'string';\n    assert std.type(from) == 'string';\n    assert std.type(to) == 'string';\n    assert from != '' : \"'from' string must not be zero length.\";\n\n    // Cache for performance.\n    local str_len = std.length(str);\n    local from_len = std.length(from);\n\n    // True if from is at str[i].\n    local found_at(i) = str[i:i + from_len] == from;\n\n    // Return the remainder of 'str' starting with 'start_index' where\n    // all occurrences of 'from' after 'curr_index' are replaced with 'to'.\n    local replace_after(start_index, curr_index, acc) =\n      if curr_index > str_len then\n        acc + str[start_index:curr_index]\n      else if found_at(curr_index) then\n        local new_index = curr_index + std.length(from);\n        replace_after(new_index, new_index, acc + str[start_index:curr_index] + to)\n      else\n        replace_after(start_index, curr_index + 1, acc);\n\n    // if from_len==1, then we replace by splitting and rejoining the\n    // string which is much faster than recursing on replace_after\n    if from_len == 1 then\n      std.join(to, std.split(str, from))\n    else\n      replace_after(0, 0, ''),\n\n  asciiUpper(x)::\n    local cp = std.codepoint;\n    local up_letter(c) = if cp(c) >= 97 && cp(c) < 123 then\n      std.char(cp(c) - 32)\n    else\n      c;\n    std.join('', std.map(up_letter, std.stringChars(x))),\n\n  asciiLower(x)::\n    local cp = std.codepoint;\n    local down_letter(c) = if cp(c) >= 65 && cp(c) < 91 then\n      std.char(cp(c) + 32)\n    else\n      c;\n    std.join('', std.map(down_letter, std.stringChars(x))),\n\n\n  range(from, to)::\n    std.makeArray(to - from + 1, function(i) i + from),\n\n  slice(indexable, index, end, step)::\n    local invar =\n      // loop invariant with defaults applied\n      {\n        indexable: indexable,\n        index:\n          if index == null then 0\n          else index,\n        end:\n          if end == null then std.length(indexable)\n          else end,\n        step:\n          if step == null then 1\n          else step,\n        length: std.length(indexable),\n        type: std.type(indexable),\n      };\n    if invar.index < 0 || invar.end < 0 || invar.step < 0 then\n      error ('got [%s:%s:%s] but negative index, end, and steps are not supported'\n             % [invar.index, invar.end, invar.step])\n    else if step == 0 then\n      error ('got %s but step must be greater than 0' % step)\n    else if std.type(indexable) != 'string' && std.type(indexable) != 'array' then\n      error ('std.slice accepts a string or an array, but got: %s' % std.type(indexable))\n    else\n      local build(slice, cur) =\n        if cur >= invar.end || cur >= invar.length then\n          slice\n        else\n          build(\n            if invar.type == 'string' then\n              slice + invar.indexable[cur]\n            else\n              slice + [invar.indexable[cur]],\n            cur + invar.step\n          ) tailstrict;\n      build(if invar.type == 'string' then '' else [], invar.index),\n\n  count(arr, x):: std.length(std.filter(function(v) v == x, arr)),\n\n  mod(a, b)::\n    if std.type(a) == 'number' && std.type(b) == 'number' then\n      std.modulo(a, b)\n    else if std.type(a) == 'string' then\n      std.format(a, b)\n    else\n      error 'Operator % cannot be used on types ' + std.type(a) + ' and ' + std.type(b) + '.',\n\n  map(func, arr)::\n    if std.type(func) != 'function' then\n      error ('std.map first param must be function, got ' + std.type(func))\n    else if std.type(arr) != 'array' && std.type(arr) != 'string' then\n      error ('std.map second param must be array / string, got ' + std.type(arr))\n    else\n      std.makeArray(std.length(arr), function(i) func(arr[i])),\n\n  mapWithIndex(func, arr)::\n    if std.type(func) != 'function' then\n      error ('std.mapWithIndex first param must be function, got ' + std.type(func))\n    else if std.type(arr) != 'array' && std.type(arr) != 'string' then\n      error ('std.mapWithIndex second param must be array, got ' + std.type(arr))\n    else\n      std.makeArray(std.length(arr), function(i) func(i, arr[i])),\n\n  mapWithKey(func, obj)::\n    if std.type(func) != 'function' then\n      error ('std.mapWithKey first param must be function, got ' + std.type(func))\n    else if std.type(obj) != 'object' then\n      error ('std.mapWithKey second param must be object, got ' + std.type(obj))\n    else\n      { [k]: func(k, obj[k]) for k in std.objectFields(obj) },\n\n  join(sep, arr)::\n    local aux(arr, i, first, running) =\n      if i >= std.length(arr) then\n        running\n      else if arr[i] == null then\n        aux(arr, i + 1, first, running) tailstrict\n      else if std.type(arr[i]) != std.type(sep) then\n        error 'expected %s but arr[%d] was %s ' % [std.type(sep), i, std.type(arr[i])]\n      else if first then\n        aux(arr, i + 1, false, running + arr[i]) tailstrict\n      else\n        aux(arr, i + 1, false, running + sep + arr[i]) tailstrict;\n    if std.type(arr) != 'array' then\n      error 'join second parameter should be array, got ' + std.type(arr)\n    else if std.type(sep) == 'string' then\n      aux(arr, 0, true, '')\n    else if std.type(sep) == 'array' then\n      aux(arr, 0, true, [])\n    else\n      error 'join first parameter should be string or array, got ' + std.type(sep),\n\n  lines(arr)::\n    std.join('\\n', arr + ['']),\n\n  deepJoin(arr)::\n    if std.isString(arr) then\n      arr\n    else if std.isArray(arr) then\n      std.join('', [std.deepJoin(x) for x in arr])\n    else\n      error 'Expected string or array, got %s' % std.type(arr),\n\n\n  format(str, vals)::\n\n    /////////////////////////////\n    // Parse the mini-language //\n    /////////////////////////////\n\n    local try_parse_mapping_key(str, i) =\n      if i >= std.length(str) then\n        error 'Truncated format code.'\n      else\n        local c = str[i];\n        if c == '(' then\n          local consume(str, j, v) =\n            if j >= std.length(str) then\n              error 'Truncated format code.'\n            else\n              local c = str[j];\n              if c != ')' then\n                consume(str, j + 1, v + c)\n              else\n                { i: j + 1, v: v };\n          consume(str, i + 1, '')\n        else\n          { i: i, v: null };\n\n    local try_parse_cflags(str, i) =\n      local consume(str, j, v) =\n        if j >= std.length(str) then\n          error 'Truncated format code.'\n        else\n          local c = str[j];\n          if c == '#' then\n            consume(str, j + 1, v { alt: true })\n          else if c == '0' then\n            consume(str, j + 1, v { zero: true })\n          else if c == '-' then\n            consume(str, j + 1, v { left: true })\n          else if c == ' ' then\n            consume(str, j + 1, v { blank: true })\n          else if c == '+' then\n            consume(str, j + 1, v { sign: true })\n          else\n            { i: j, v: v };\n      consume(str, i, { alt: false, zero: false, left: false, blank: false, sign: false });\n\n    local try_parse_field_width(str, i) =\n      if i < std.length(str) && str[i] == '*' then\n        { i: i + 1, v: '*' }\n      else\n        local consume(str, j, v) =\n          if j >= std.length(str) then\n            error 'Truncated format code.'\n          else\n            local c = str[j];\n            if c == '0' then\n              consume(str, j + 1, v * 10 + 0)\n            else if c == '1' then\n              consume(str, j + 1, v * 10 + 1)\n            else if c == '2' then\n              consume(str, j + 1, v * 10 + 2)\n            else if c == '3' then\n              consume(str, j + 1, v * 10 + 3)\n            else if c == '4' then\n              consume(str, j + 1, v * 10 + 4)\n            else if c == '5' then\n              consume(str, j + 1, v * 10 + 5)\n            else if c == '6' then\n              consume(str, j + 1, v * 10 + 6)\n            else if c == '7' then\n              consume(str, j + 1, v * 10 + 7)\n            else if c == '8' then\n              consume(str, j + 1, v * 10 + 8)\n            else if c == '9' then\n              consume(str, j + 1, v * 10 + 9)\n            else\n              { i: j, v: v };\n        consume(str, i, 0);\n\n    local try_parse_precision(str, i) =\n      if i >= std.length(str) then\n        error 'Truncated format code.'\n      else\n        local c = str[i];\n        if c == '.' then\n          try_parse_field_width(str, i + 1)\n        else\n          { i: i, v: null };\n\n    // Ignored, if it exists.\n    local try_parse_length_modifier(str, i) =\n      if i >= std.length(str) then\n        error 'Truncated format code.'\n      else\n        local c = str[i];\n        if c == 'h' || c == 'l' || c == 'L' then\n          i + 1\n        else\n          i;\n\n    local parse_conv_type(str, i) =\n      if i >= std.length(str) then\n        error 'Truncated format code.'\n      else\n        local c = str[i];\n        if c == 'd' || c == 'i' || c == 'u' then\n          { i: i + 1, v: 'd', caps: false }\n        else if c == 'o' then\n          { i: i + 1, v: 'o', caps: false }\n        else if c == 'x' then\n          { i: i + 1, v: 'x', caps: false }\n        else if c == 'X' then\n          { i: i + 1, v: 'x', caps: true }\n        else if c == 'e' then\n          { i: i + 1, v: 'e', caps: false }\n        else if c == 'E' then\n          { i: i + 1, v: 'e', caps: true }\n        else if c == 'f' then\n          { i: i + 1, v: 'f', caps: false }\n        else if c == 'F' then\n          { i: i + 1, v: 'f', caps: true }\n        else if c == 'g' then\n          { i: i + 1, v: 'g', caps: false }\n        else if c == 'G' then\n          { i: i + 1, v: 'g', caps: true }\n        else if c == 'c' then\n          { i: i + 1, v: 'c', caps: false }\n        else if c == 's' then\n          { i: i + 1, v: 's', caps: false }\n        else if c == '%' then\n          { i: i + 1, v: '%', caps: false }\n        else\n          error 'Unrecognised conversion type: ' + c;\n\n\n    // Parsed initial %, now the rest.\n    local parse_code(str, i) =\n      if i >= std.length(str) then\n        error 'Truncated format code.'\n      else\n        local mkey = try_parse_mapping_key(str, i);\n        local cflags = try_parse_cflags(str, mkey.i);\n        local fw = try_parse_field_width(str, cflags.i);\n        local prec = try_parse_precision(str, fw.i);\n        local len_mod = try_parse_length_modifier(str, prec.i);\n        local ctype = parse_conv_type(str, len_mod);\n        {\n          i: ctype.i,\n          code: {\n            mkey: mkey.v,\n            cflags: cflags.v,\n            fw: fw.v,\n            prec: prec.v,\n            ctype: ctype.v,\n            caps: ctype.caps,\n          },\n        };\n\n    // Parse a format string (containing none or more % format tags).\n    local parse_codes(str, i, out, cur) =\n      if i >= std.length(str) then\n        out + [cur]\n      else\n        local c = str[i];\n        if c == '%' then\n          local r = parse_code(str, i + 1);\n          parse_codes(str, r.i, out + [cur, r.code], '') tailstrict\n        else\n          parse_codes(str, i + 1, out, cur + c) tailstrict;\n\n    local codes = parse_codes(str, 0, [], '');\n\n\n    ///////////////////////\n    // Format the values //\n    ///////////////////////\n\n    // Useful utilities\n    local padding(w, s) =\n      local aux(w, v) =\n        if w <= 0 then\n          v\n        else\n          aux(w - 1, v + s);\n      aux(w, '');\n\n    // Add s to the left of str so that its length is at least w.\n    local pad_left(str, w, s) =\n      padding(w - std.length(str), s) + str;\n\n    // Add s to the right of str so that its length is at least w.\n    local pad_right(str, w, s) =\n      str + padding(w - std.length(str), s);\n\n    // Render an integer (e.g., decimal or octal).\n    local render_int(n__, min_chars, min_digits, blank, sign, radix, zero_prefix) =\n      local n_ = std.abs(n__);\n      local aux(n) =\n        if n == 0 then\n          zero_prefix\n        else\n          aux(std.floor(n / radix)) + (n % radix);\n      local dec = if std.floor(n_) == 0 then '0' else aux(std.floor(n_));\n      local neg = n__ < 0;\n      local zp = min_chars - (if neg || blank || sign then 1 else 0);\n      local zp2 = std.max(zp, min_digits);\n      local dec2 = pad_left(dec, zp2, '0');\n      (if neg then '-' else if sign then '+' else if blank then ' ' else '') + dec2;\n\n    // Render an integer in hexadecimal.\n    local render_hex(n__, min_chars, min_digits, blank, sign, add_zerox, capitals) =\n      local numerals = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n                       + if capitals then ['A', 'B', 'C', 'D', 'E', 'F']\n                       else ['a', 'b', 'c', 'd', 'e', 'f'];\n      local n_ = std.abs(n__);\n      local aux(n) =\n        if n == 0 then\n          ''\n        else\n          aux(std.floor(n / 16)) + numerals[n % 16];\n      local hex = if std.floor(n_) == 0 then '0' else aux(std.floor(n_));\n      local neg = n__ < 0;\n      local zp = min_chars - (if neg || blank || sign then 1 else 0)\n                 - (if add_zerox then 2 else 0);\n      local zp2 = std.max(zp, min_digits);\n      local hex2 = (if add_zerox then (if capitals then '0X' else '0x') else '')\n                   + pad_left(hex, zp2, '0');\n      (if neg then '-' else if sign then '+' else if blank then ' ' else '') + hex2;\n\n    local strip_trailing_zero(str) =\n      local aux(str, i) =\n        if i < 0 then\n          ''\n        else\n          if str[i] == '0' then\n            aux(str, i - 1)\n          else\n            std.substr(str, 0, i + 1);\n      aux(str, std.length(str) - 1);\n\n    // Render floating point in decimal form\n    local render_float_dec(n__, zero_pad, blank, sign, ensure_pt, trailing, prec) =\n      local n_ = std.abs(n__);\n      local whole = std.floor(n_);\n      local dot_size = if prec == 0 && !ensure_pt then 0 else 1;\n      local zp = zero_pad - prec - dot_size;\n      local str = render_int(std.sign(n__) * whole, zp, 0, blank, sign, 10, '');\n      if prec == 0 then\n        str + if ensure_pt then '.' else ''\n      else\n        local frac = std.floor((n_ - whole) * std.pow(10, prec) + 0.5);\n        if trailing || frac > 0 then\n          local frac_str = render_int(frac, prec, 0, false, false, 10, '');\n          str + '.' + if !trailing then strip_trailing_zero(frac_str) else frac_str\n        else\n          str;\n\n    // Render floating point in scientific form\n    local render_float_sci(n__, zero_pad, blank, sign, ensure_pt, trailing, caps, prec) =\n      local exponent = std.floor(std.log(std.abs(n__)) / std.log(10));\n      local suff = (if caps then 'E' else 'e')\n                   + render_int(exponent, 3, 0, false, true, 10, '');\n      local mantissa = n__ / std.pow(10, exponent);\n      local zp2 = zero_pad - std.length(suff);\n      render_float_dec(mantissa, zp2, blank, sign, ensure_pt, trailing, prec) + suff;\n\n    // Render a value with an arbitrary format code.\n    local format_code(val, code, fw, prec_or_null, i) =\n      local cflags = code.cflags;\n      local fpprec = if prec_or_null != null then prec_or_null else 6;\n      local iprec = if prec_or_null != null then prec_or_null else 0;\n      local zp = if cflags.zero && !cflags.left then fw else 0;\n      if code.ctype == 's' then\n        std.toString(val)\n      else if code.ctype == 'd' then\n        if std.type(val) != 'number' then\n          error 'Format required number at '\n                + i + ', got ' + std.type(val)\n        else\n          render_int(val, zp, iprec, cflags.blank, cflags.sign, 10, '')\n      else if code.ctype == 'o' then\n        if std.type(val) != 'number' then\n          error 'Format required number at '\n                + i + ', got ' + std.type(val)\n        else\n          local zero_prefix = if cflags.alt then '0' else '';\n          render_int(val, zp, iprec, cflags.blank, cflags.sign, 8, zero_prefix)\n      else if code.ctype == 'x' then\n        if std.type(val) != 'number' then\n          error 'Format required number at '\n                + i + ', got ' + std.type(val)\n        else\n          render_hex(val,\n                     zp,\n                     iprec,\n                     cflags.blank,\n                     cflags.sign,\n                     cflags.alt,\n                     code.caps)\n      else if code.ctype == 'f' then\n        if std.type(val) != 'number' then\n          error 'Format required number at '\n                + i + ', got ' + std.type(val)\n        else\n          render_float_dec(val,\n                           zp,\n                           cflags.blank,\n                           cflags.sign,\n                           cflags.alt,\n                           true,\n                           fpprec)\n      else if code.ctype == 'e' then\n        if std.type(val) != 'number' then\n          error 'Format required number at '\n                + i + ', got ' + std.type(val)\n        else\n          render_float_sci(val,\n                           zp,\n                           cflags.blank,\n                           cflags.sign,\n                           cflags.alt,\n                           true,\n                           code.caps,\n                           fpprec)\n      else if code.ctype == 'g' then\n        if std.type(val) != 'number' then\n          error 'Format required number at '\n                + i + ', got ' + std.type(val)\n        else\n          local exponent = std.floor(std.log(std.abs(val)) / std.log(10));\n          if exponent < -4 || exponent >= fpprec then\n            render_float_sci(val,\n                             zp,\n                             cflags.blank,\n                             cflags.sign,\n                             cflags.alt,\n                             cflags.alt,\n                             code.caps,\n                             fpprec - 1)\n          else\n            local digits_before_pt = std.max(1, exponent + 1);\n            render_float_dec(val,\n                             zp,\n                             cflags.blank,\n                             cflags.sign,\n                             cflags.alt,\n                             cflags.alt,\n                             fpprec - digits_before_pt)\n      else if code.ctype == 'c' then\n        if std.type(val) == 'number' then\n          std.char(val)\n        else if std.type(val) == 'string' then\n          if std.length(val) == 1 then\n            val\n          else\n            error '%c expected 1-sized string got: ' + std.length(val)\n        else\n          error '%c expected number / string, got: ' + std.type(val)\n      else\n        error 'Unknown code: ' + code.ctype;\n\n    // Render a parsed format string with an array of values.\n    local format_codes_arr(codes, arr, i, j, v) =\n      if i >= std.length(codes) then\n        if j < std.length(arr) then\n          error ('Too many values to format: ' + std.length(arr) + ', expected ' + j)\n        else\n          v\n      else\n        local code = codes[i];\n        if std.type(code) == 'string' then\n          format_codes_arr(codes, arr, i + 1, j, v + code) tailstrict\n        else\n          local tmp = if code.fw == '*' then {\n            j: j + 1,\n            fw: if j >= std.length(arr) then\n              error 'Not enough values to format: ' + std.length(arr)\n            else\n              arr[j],\n          } else {\n            j: j,\n            fw: code.fw,\n          };\n          local tmp2 = if code.prec == '*' then {\n            j: tmp.j + 1,\n            prec: if tmp.j >= std.length(arr) then\n              error 'Not enough values to format: ' + std.length(arr)\n            else\n              arr[tmp.j],\n          } else {\n            j: tmp.j,\n            prec: code.prec,\n          };\n          local j2 = tmp2.j;\n          local val =\n            if j2 < std.length(arr) then\n              arr[j2]\n            else\n              error 'Not enough values to format, got ' + std.length(arr);\n          local s =\n            if code.ctype == '%' then\n              '%'\n            else\n              format_code(val, code, tmp.fw, tmp2.prec, j2);\n          local s_padded =\n            if code.cflags.left then\n              pad_right(s, tmp.fw, ' ')\n            else\n              pad_left(s, tmp.fw, ' ');\n          local j3 =\n            if code.ctype == '%' then\n              j2\n            else\n              j2 + 1;\n          format_codes_arr(codes, arr, i + 1, j3, v + s_padded) tailstrict;\n\n    // Render a parsed format string with an object of values.\n    local format_codes_obj(codes, obj, i, v) =\n      if i >= std.length(codes) then\n        v\n      else\n        local code = codes[i];\n        if std.type(code) == 'string' then\n          format_codes_obj(codes, obj, i + 1, v + code) tailstrict\n        else\n          local f =\n            if code.mkey == null then\n              error 'Mapping keys required.'\n            else\n              code.mkey;\n          local fw =\n            if code.fw == '*' then\n              error 'Cannot use * field width with object.'\n            else\n              code.fw;\n          local prec =\n            if code.prec == '*' then\n              error 'Cannot use * precision with object.'\n            else\n              code.prec;\n          local val =\n            if std.objectHasAll(obj, f) then\n              obj[f]\n            else\n              error 'No such field: ' + f;\n          local s =\n            if code.ctype == '%' then\n              '%'\n            else\n              format_code(val, code, fw, prec, f);\n          local s_padded =\n            if code.cflags.left then\n              pad_right(s, fw, ' ')\n            else\n              pad_left(s, fw, ' ');\n          format_codes_obj(codes, obj, i + 1, v + s_padded) tailstrict;\n\n    if std.type(vals) == 'array' then\n      format_codes_arr(codes, vals, 0, 0, '')\n    else if std.type(vals) == 'object' then\n      format_codes_obj(codes, vals, 0, '')\n    else\n      format_codes_arr(codes, [vals], 0, 0, ''),\n\n  foldr(func, arr, init)::\n    local aux(func, arr, running, idx) =\n      if idx < 0 then\n        running\n      else\n        aux(func, arr, func(arr[idx], running), idx - 1) tailstrict;\n    aux(func, arr, init, std.length(arr) - 1),\n\n  foldl(func, arr, init)::\n    local aux(func, arr, running, idx) =\n      if idx >= std.length(arr) then\n        running\n      else\n        aux(func, arr, func(running, arr[idx]), idx + 1) tailstrict;\n    aux(func, arr, init, 0),\n\n\n  filterMap(filter_func, map_func, arr)::\n    if std.type(filter_func) != 'function' then\n      error ('std.filterMap first param must be function, got ' + std.type(filter_func))\n    else if std.type(map_func) != 'function' then\n      error ('std.filterMap second param must be function, got ' + std.type(map_func))\n    else if std.type(arr) != 'array' then\n      error ('std.filterMap third param must be array, got ' + std.type(arr))\n    else\n      std.map(map_func, std.filter(filter_func, arr)),\n\n  assertEqual(a, b)::\n    if a == b then\n      true\n    else\n      error 'Assertion failed. ' + a + ' != ' + b,\n\n  abs(n)::\n    if std.type(n) != 'number' then\n      error 'std.abs expected number, got ' + std.type(n)\n    else\n      if n > 0 then n else -n,\n\n  sign(n)::\n    if std.type(n) != 'number' then\n      error 'std.sign expected number, got ' + std.type(n)\n    else\n      if n > 0 then\n        1\n      else if n < 0 then\n        -1\n      else 0,\n\n  max(a, b)::\n    if std.type(a) != 'number' then\n      error 'std.max first param expected number, got ' + std.type(a)\n    else if std.type(b) != 'number' then\n      error 'std.max second param expected number, got ' + std.type(b)\n    else\n      if a > b then a else b,\n\n  min(a, b)::\n    if std.type(a) != 'number' then\n      error 'std.max first param expected number, got ' + std.type(a)\n    else if std.type(b) != 'number' then\n      error 'std.max second param expected number, got ' + std.type(b)\n    else\n      if a < b then a else b,\n\n  flattenArrays(arrs)::\n    std.foldl(function(a, b) a + b, arrs, []),\n\n  manifestIni(ini)::\n    local body_lines(body) =\n      std.join([], [\n        local value_or_values = body[k];\n        if std.type(value_or_values) == 'array' then\n          ['%s = %s' % [k, value] for value in value_or_values]\n        else\n          ['%s = %s' % [k, value_or_values]]\n\n        for k in std.objectFields(body)\n      ]);\n\n    local section_lines(sname, sbody) = ['[%s]' % [sname]] + body_lines(sbody),\n          main_body = if std.objectHas(ini, 'main') then body_lines(ini.main) else [],\n          all_sections = [\n      section_lines(k, ini.sections[k])\n      for k in std.objectFields(ini.sections)\n    ];\n    std.join('\\n', main_body + std.flattenArrays(all_sections) + ['']),\n\n  escapeStringJson(str_)::\n    local str = std.toString(str_);\n    local trans(ch) =\n      if ch == '\"' then\n        '\\\\\"'\n      else if ch == '\\\\' then\n        '\\\\\\\\'\n      else if ch == '\\b' then\n        '\\\\b'\n      else if ch == '\\f' then\n        '\\\\f'\n      else if ch == '\\n' then\n        '\\\\n'\n      else if ch == '\\r' then\n        '\\\\r'\n      else if ch == '\\t' then\n        '\\\\t'\n      else\n        local cp = std.codepoint(ch);\n        if cp < 32 || (cp >= 126 && cp <= 159) then\n          '\\\\u%04x' % [cp]\n        else\n          ch;\n    '\"%s\"' % std.join('', [trans(ch) for ch in std.stringChars(str)]),\n\n  escapeStringPython(str)::\n    std.escapeStringJson(str),\n\n  escapeStringBash(str_)::\n    local str = std.toString(str_);\n    local trans(ch) =\n      if ch == \"'\" then\n        \"'\\\"'\\\"'\"\n      else\n        ch;\n    \"'%s'\" % std.join('', [trans(ch) for ch in std.stringChars(str)]),\n\n  escapeStringDollars(str_)::\n    local str = std.toString(str_);\n    local trans(ch) =\n      if ch == '$' then\n        '$$'\n      else\n        ch;\n    std.foldl(function(a, b) a + trans(b), std.stringChars(str), ''),\n\n  manifestJson(value):: std.manifestJsonEx(value, '    '),\n\n  manifestJsonEx(value, indent)::\n    local aux(v, path, cindent) =\n      if v == true then\n        'true'\n      else if v == false then\n        'false'\n      else if v == null then\n        'null'\n      else if std.type(v) == 'number' then\n        '' + v\n      else if std.type(v) == 'string' then\n        std.escapeStringJson(v)\n      else if std.type(v) == 'function' then\n        error 'Tried to manifest function at ' + path\n      else if std.type(v) == 'array' then\n        local range = std.range(0, std.length(v) - 1);\n        local new_indent = cindent + indent;\n        local lines = ['[\\n']\n                      + std.join([',\\n'],\n                                 [\n                                   [new_indent + aux(v[i], path + [i], new_indent)]\n                                   for i in range\n                                 ])\n                      + ['\\n' + cindent + ']'];\n        std.join('', lines)\n      else if std.type(v) == 'object' then\n        local lines = ['{\\n']\n                      + std.join([',\\n'],\n                                 [\n                                   [cindent + indent + std.escapeStringJson(k) + ': '\n                                    + aux(v[k], path + [k], cindent + indent)]\n                                   for k in std.objectFields(v)\n                                 ])\n                      + ['\\n' + cindent + '}'];\n        std.join('', lines);\n    aux(value, [], ''),\n\n  manifestYamlDoc(value)::\n    local aux(v, in_object, path, cindent) =\n      if v == true then\n        'true'\n      else if v == false then\n        'false'\n      else if v == null then\n        'null'\n      else if std.type(v) == 'number' then\n        '' + v\n      else if std.type(v) == 'string' then\n        local len = std.length(v);\n        if len == 0 then\n          '\"\"'\n        else if v[len - 1] == '\\n' then\n          local split = std.split(v, '\\n');\n          std.join('\\n' + cindent, ['|'] + split[0:std.length(split) - 1])\n        else\n          std.escapeStringJson(v)\n      else if std.type(v) == 'function' then\n        error 'Tried to manifest function at ' + path\n      else if std.type(v) == 'array' then\n        if std.length(v) == 0 then\n          '[]'\n        else\n          local range = std.range(0, std.length(v) - 1);\n          local actual_indent = if in_object then cindent[2:] else cindent;\n          local parts = [aux(v[i], false, path + [i], cindent) for i in range];\n          (if in_object then '\\n' + actual_indent else '')\n          + '- ' + std.join('\\n' + actual_indent + '- ', parts)\n      else if std.type(v) == 'object' then\n        if std.length(v) == 0 then\n          '{}'\n        else\n          local new_indent = cindent + '  ';\n          local lines = [\n            std.escapeStringJson(k) + ': ' + aux(v[k], true, path + [k], new_indent)\n            for k in std.objectFields(v)\n          ];\n          (if in_object then '\\n' + cindent else '') + std.join('\\n' + cindent, lines);\n    aux(value, false, [], ''),\n\n  manifestYamlStream(value)::\n    if std.type(value) != 'array' then\n      error 'manifestYamlStream only takes arrays, got ' + std.type(value)\n    else\n      '---\\n' + std.join('\\n---\\n', [std.manifestYamlDoc(e) for e in value]) + '\\n...\\n',\n\n\n  manifestPython(o)::\n    if std.type(o) == 'object' then\n      local fields = [\n        '%s: %s' % [std.escapeStringPython(k), std.manifestPython(o[k])]\n        for k in std.objectFields(o)\n      ];\n      '{%s}' % [std.join(', ', fields)]\n    else if std.type(o) == 'array' then\n      '[%s]' % [std.join(', ', [std.manifestPython(o2) for o2 in o])]\n    else if std.type(o) == 'string' then\n      '%s' % [std.escapeStringPython(o)]\n    else if std.type(o) == 'function' then\n      error 'cannot manifest function'\n    else if std.type(o) == 'number' then\n      std.toString(o)\n    else if o == true then\n      'True'\n    else if o == false then\n      'False'\n    else if o == null then\n      'None',\n\n  manifestPythonVars(conf)::\n    local vars = ['%s = %s' % [k, std.manifestPython(conf[k])] for k in std.objectFields(conf)];\n    std.join('\\n', vars + ['']),\n\n  manifestXmlJsonml(value)::\n    if !std.isArray(value) then\n      error 'Expected a JSONML value (an array), got %s' % std.type(value)\n    else\n      local aux(v) =\n        if std.isString(v) then\n          v\n        else\n          local tag = v[0];\n          local has_attrs = std.length(v) > 1 && std.type(v[1]) == 'object';\n          local attrs = if has_attrs then v[1] else {};\n          local children = if has_attrs then v[2:] else v[1:];\n          local attrs_str =\n            std.join('', [' %s=\"%s\"' % [k, attrs[k]] for k in std.objectFields(attrs)]);\n          std.deepJoin(['<', tag, attrs_str, '>', [aux(x) for x in children], '</', tag, '>']);\n\n      aux(value),\n\n  local base64_table = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/',\n  local base64_inv = { [base64_table[i]]: i for i in std.range(0, 63) },\n\n  base64(input)::\n    local bytes =\n      if std.type(input) == 'string' then\n        std.map(function(c) std.codepoint(c), input)\n      else\n        input;\n\n    local aux(arr, i, r) =\n      if i >= std.length(arr) then\n        r\n      else if i + 1 >= std.length(arr) then\n        local str =\n          // 6 MSB of i\n          base64_table[(arr[i] & 252) >> 2] +\n          // 2 LSB of i\n          base64_table[(arr[i] & 3) << 4] +\n          '==';\n        aux(arr, i + 3, r + str) tailstrict\n      else if i + 2 >= std.length(arr) then\n        local str =\n          // 6 MSB of i\n          base64_table[(arr[i] & 252) >> 2] +\n          // 2 LSB of i, 4 MSB of i+1\n          base64_table[(arr[i] & 3) << 4 | (arr[i + 1] & 240) >> 4] +\n          // 4 LSB of i+1\n          base64_table[(arr[i + 1] & 15) << 2] +\n          '=';\n        aux(arr, i + 3, r + str) tailstrict\n      else\n        local str =\n          // 6 MSB of i\n          base64_table[(arr[i] & 252) >> 2] +\n          // 2 LSB of i, 4 MSB of i+1\n          base64_table[(arr[i] & 3) << 4 | (arr[i + 1] & 240) >> 4] +\n          // 4 LSB of i+1, 2 MSB of i+2\n          base64_table[(arr[i + 1] & 15) << 2 | (arr[i + 2] & 192) >> 6] +\n          // 6 LSB of i+2\n          base64_table[(arr[i + 2] & 63)];\n        aux(arr, i + 3, r + str) tailstrict;\n\n    local sanity = std.foldl(function(r, a) r && (a < 256), bytes, true);\n    if !sanity then\n      error 'Can only base64 encode strings / arrays of single bytes.'\n    else\n      aux(bytes, 0, ''),\n\n\n  base64DecodeBytes(str)::\n    if std.length(str) % 4 != 0 then\n      error 'Not a base64 encoded string \"%s\"' % str\n    else\n      local aux(str, i, r) =\n        if i >= std.length(str) then\n          r\n        else\n          // all 6 bits of i, 2 MSB of i+1\n          local n1 = [base64_inv[str[i]] << 2 | (base64_inv[str[i + 1]] >> 4)];\n          // 4 LSB of i+1, 4MSB of i+2\n          local n2 =\n            if str[i + 2] == '=' then []\n            else [(base64_inv[str[i + 1]] & 15) << 4 | (base64_inv[str[i + 2]] >> 2)];\n          // 2 LSB of i+2, all 6 bits of i+3\n          local n3 =\n            if str[i + 3] == '=' then []\n            else [(base64_inv[str[i + 2]] & 3) << 6 | base64_inv[str[i + 3]]];\n          aux(str, i + 4, r + n1 + n2 + n3) tailstrict;\n      aux(str, 0, []),\n\n  base64Decode(str)::\n    local bytes = std.base64DecodeBytes(str);\n    std.join('', std.map(function(b) std.char(b), bytes)),\n\n  // Quicksort\n  sort(arr, keyF=id)::\n    local l = std.length(arr);\n    if std.length(arr) == 0 then\n      []\n    else\n      local pivot = keyF(arr[0]);\n      local rest = std.makeArray(l - 1, function(i) arr[i + 1]);\n      local left = std.filter(function(x) keyF(x) < pivot, rest);\n      local right = std.filter(function(x) keyF(x) >= pivot, rest);\n      std.sort(left, keyF) + [arr[0]] + std.sort(right, keyF),\n\n  uniq(arr, keyF=id)::\n    local f(a, b) =\n      if std.length(a) == 0 then\n        [b]\n      else if keyF(a[std.length(a) - 1]) == keyF(b) then\n        a\n      else\n        a + [b];\n    std.foldl(f, arr, []),\n\n  set(arr, keyF=id)::\n    std.uniq(std.sort(arr, keyF), keyF),\n\n  setMember(x, arr, keyF=id)::\n    // TODO(dcunnin): Binary chop for O(log n) complexity\n    std.length(std.setInter([x], arr, keyF)) > 0,\n\n  setUnion(a, b, keyF=id)::\n    // NOTE: order matters, values in `a` win due to sort being stable\n    std.set(a + b, keyF),\n\n  setInter(a, b, keyF=id)::\n    local aux(a, b, i, j, acc) =\n      if i >= std.length(a) || j >= std.length(b) then\n        acc\n      else\n        if keyF(a[i]) == keyF(b[j]) then\n          aux(a, b, i + 1, j + 1, acc + [a[i]]) tailstrict\n        else if keyF(a[i]) < keyF(b[j]) then\n          aux(a, b, i + 1, j, acc) tailstrict\n        else\n          aux(a, b, i, j + 1, acc) tailstrict;\n    aux(a, b, 0, 0, []) tailstrict,\n\n  setDiff(a, b, keyF=id)::\n    local aux(a, b, i, j, acc) =\n      if i >= std.length(a) then\n        acc\n      else if j >= std.length(b) then\n        aux(a, b, i + 1, j, acc + [a[i]]) tailstrict\n      else\n        if keyF(a[i]) == keyF(b[j]) then\n          aux(a, b, i + 1, j + 1, acc) tailstrict\n        else if keyF(a[i]) < keyF(b[j]) then\n          aux(a, b, i + 1, j, acc + [a[i]]) tailstrict\n        else\n          aux(a, b, i, j + 1, acc) tailstrict;\n    aux(a, b, 0, 0, []) tailstrict,\n\n  mergePatch(target, patch)::\n    if std.type(patch) == 'object' then\n      local target_object =\n        if std.type(target) == 'object' then target else {};\n\n      local target_fields =\n        if std.type(target_object) == 'object' then std.objectFields(target_object) else [];\n\n      local null_fields = [k for k in std.objectFields(patch) if patch[k] == null];\n      local both_fields = std.setUnion(target_fields, std.objectFields(patch));\n\n      {\n        [k]:\n          if !std.objectHas(patch, k) then\n            target_object[k]\n          else if !std.objectHas(target_object, k) then\n            std.mergePatch(null, patch[k]) tailstrict\n          else\n            std.mergePatch(target_object[k], patch[k]) tailstrict\n        for k in std.setDiff(both_fields, null_fields)\n      }\n    else\n      patch,\n\n  objectFields(o)::\n    std.objectFieldsEx(o, false),\n\n  objectFieldsAll(o)::\n    std.objectFieldsEx(o, true),\n\n  objectHas(o, f)::\n    std.objectHasEx(o, f, false),\n\n  objectHasAll(o, f)::\n    std.objectHasEx(o, f, true),\n\n  equals(a, b)::\n    local ta = std.type(a);\n    local tb = std.type(b);\n    if !std.primitiveEquals(ta, tb) then\n      false\n    else\n      if std.primitiveEquals(ta, 'array') then\n        local la = std.length(a);\n        if !std.primitiveEquals(la, std.length(b)) then\n          false\n        else\n          local aux(a, b, i) =\n            if i >= la then\n              true\n            else if a[i] != b[i] then\n              false\n            else\n              aux(a, b, i + 1) tailstrict;\n          aux(a, b, 0)\n      else if std.primitiveEquals(ta, 'object') then\n        local fields = std.objectFields(a);\n        local lfields = std.length(fields);\n        if fields != std.objectFields(b) then\n          false\n        else\n          local aux(a, b, i) =\n            if i >= lfields then\n              true\n            else if local f = fields[i]; a[f] != b[f] then\n              false\n            else\n              aux(a, b, i + 1) tailstrict;\n          aux(a, b, 0)\n      else\n        std.primitiveEquals(a, b),\n\n\n  resolvePath(f, r)::\n    local arr = std.split(f, '/');\n    std.join('/', std.makeArray(std.length(arr) - 1, function(i) arr[i]) + [r]),\n\n  prune(a)::\n    local isContent(b) =\n      local t = std.type(b);\n      if b == null then\n        false\n      else if t == 'array' then\n        std.length(b) > 0\n      else if t == 'object' then\n        std.length(b) > 0\n      else\n        true;\n    local t = std.type(a);\n    if t == 'array' then\n      [std.prune(x) for x in a if isContent($.prune(x))]\n    else if t == 'object' then {\n      [x]: $.prune(a[x])\n      for x in std.objectFields(a)\n      if isContent(std.prune(a[x]))\n    } else\n      a,\n}\n"),
	}

	// define dirs
	dir1 := &embedded.EmbeddedDir{
		Filename:   "",
		DirModTime: time.Unix(1535557040, 0),
		ChildFiles: []*embedded.EmbeddedFile{
			file2, // "std.jsonnet"

		},
	}

	// link ChildDirs
	dir1.ChildDirs = []*embedded.EmbeddedDir{}

	// register embeddedBox
	embedded.RegisterEmbeddedBox(`ext`, &embedded.EmbeddedBox{
		Name: `ext`,
		Time: time.Unix(1535557040, 0),
		Dirs: map[string]*embedded.EmbeddedDir{
			"": dir1,
		},
		Files: map[string]*embedded.EmbeddedFile{
			"std.jsonnet": file2,
		},
	})
}
